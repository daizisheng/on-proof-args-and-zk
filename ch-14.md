# 第十四章 基于离散对数困难性的多项式承诺

*多项式承诺以及一个简单方案。* 回想一下，所谓的多项式承诺，实际上是针对如下理想化过程的一个模拟。有一个不受信任的证明者 $\mathcal{P}$，他脑子里有一个多项式 $q$（在所谓<u>简洁论证</u>的相关应用里面，对于多项式 $q$，我们主要关心两种情况，一是单变量多项式，一是多线性多项式）。 $\mathcal{P}$ 向验证者 $\mathcal{V}$ 发送 $q$ 的完整描述（比如， $q$ 的所有系数组成的列表）。 $\mathcal{V}$ 得到 $q$ 后，可以选择任何点 $z$，并在 $z$ 点对多项式 $q$ 进行赋值。而一旦 $\mathcal{P}$ 将多项式 $q$ 发送给 $\mathcal{V}$，无论 $\mathcal{V}$ 选择在哪个点对多项式进行赋值， $\mathcal{P}$ 都无法再更换多项式 $q$ 本身（译者：“无法更换”在这里过于明显，让人觉得多此一举，其贴切含义需要阅读后续内容）。在上述过程中， $\mathcal{P}$ 显式地将多项式 $q$ 的完整描述发送给 $\mathcal{V}$，我们称其为一个平凡的多项式承诺方案。

上述平凡的多项式承诺方案存在三个潜在问题，其中有两个和效率有关。

* 如果将多项式承诺应用于 SNARK（见第7-10章），多项式 $q$ 可能非常大。 事实上， $q$ 通常与所要证明的整个命题一样大。因此，让 $\mathcal{P}$ 将 $q$ 的所有系数都发送给 $\mathcal{V}$ 的话，将产生大量的通信。所以，使用上述平凡的多项式承诺将无法产生<u>简洁论证</u>。

* $\mathcal{V}$ 为了计算 $q(z)$ ，需要花费的时间将与多项式的系数个数成正比。如果我们希望产生更加节省计算量的论证， 也就是说，希望验证者能够更快的接收并验证证据的话， 上述平凡的承诺方案将无法满足要求。

* $\mathcal{V}$ 获得了整个多项式 $q$。这可能与零知识的要求冲突。在 SNARK 的应用中， $q$ 通常是某个证据的编码，而将整个 $q$ 发送给 $\mathcal{V}$ 的话， 就泄漏了这个证据的全部。

使用密码学工具，我们可以在克服上述三个问题的同时，实现与平凡多项式承诺方案相同的功能。具体而言，针对多项式 $q$ ， $\mathcal{P}$ 可以计算一个压缩的承诺 $c$，并把 $c$ 发送给验证者。压缩意味着 $c$ 比 $q$ 小得多，这就解决了关于简洁性的第一个问题。同时，由于 $c$ 比 $q$ （译者：原文为 $p$ ，疑似有误） 本身小，所以 $c$ 并未将 $\mathcal{P}$ 拥有的 $q$ 完全固定下来。这也就是说，对许多不同的多项式而言， $c$ 都是有效的承诺，对随后的进一步的验证请求， $\mathcal{P}$ 还有一定的选择空间。当验证者要求 $\mathcal{P}$ 计算 $q(z)$ 时， $\mathcal{P}$ 还能够在多个符合承诺为 $c$ 的多项式中，选择一个 $p$ ，并返回对应的赋值 $p(z)$。虽然如此，我们依然可能设计出一种多项式承诺方案，并要求其在可计算意义上对 $q$ 进行了固定。这里的意思是，任何<u>有效证明者</u>（比如，无法解决离散对数问题，或在密码哈希函数中无法找到碰撞的证明者），在处理针对所承诺的多项式的赋值请求 $z$ 时，都无法用 $q(z)$ 以外的任何值来进行回应。更准确地说，除了声称 $q(z)$ 的值为 $v$ 之外，证明者还将发送一个赋值证明 $\pi$。<u>可计算约束</u>保证了，除非有 $v=q(z)$，否则任何<u>有效证明者</u>都无法生成一个令人信服的 $\pi$。

在前面的章节中，我们介绍过一些多项式承诺方案（例如，第10.4.2节和第10.5节）。在本章，我们将讨论更多的承诺方案。这些方案和之前的那些方案类似，在 $\pi$ 的验证上，所花费的时间，相比于即使仅仅读取完整 $q$ 所需的时间，都要少得多。这就解决了平凡承诺方案的前两个问题（即简洁性和验证需要花费太多时间的问题）。我们还将看到一些方案，在这些方案中，证据 $\pi$ 不会泄露关于 $q$ 的任何信息。甚至还有一些方案，其中验证者实际上连 $q(z)$ 都不知道，而作为替代，只会得到一个 $q(z)$ 的隐藏承诺。有了这些方案，多项式承诺就可以支持<u>零知识</u>，而不会泄露关于 $q$（当然也包括它所编码的证据）的任何信息给验证者。

*披露 $q(z)$ 本身还是对 $q(z)$ 的承诺。* 本章描述的多项式承诺方案，将向验证者披露赋值 $v = q(z)$ 的<u>（Pedersen）承诺</u>（译者：而不是 $v$ 本身）。这是因为第13.2节中的<u>零知识论证</u>需要如此。而其它<u>零知识论证</u>（如第13.3节）则要求 $v$ 被显式的披露出来。幸运的是，如果想要修改本章的承诺方案，以向验证者披露 $v$ ，也是比较容易做到的。例如，可以让证明者使用协议3，在保证零知识的同时，向验证者<u>打开</u>对 $v$ 的承诺，也就是披露 $v$ 的值（参见第12.3.1节的最后一段）。而后面将在第15章描述，在基于<u>配对</u>的多项式承诺方案中，赋值 $v = q(z)$ 将被显式的披露给验证者。

*前面章节的多项式承诺对比本章将要描述的方案。* 之前讲到，一种构建多项式承诺的方法是，将某种合适的PCP或IOP与<u>Merkle哈希</u>结合起来（第10.4.2节和第10.5节）。相比于<u>Merkle哈希</u>方法利用的是“对称密钥”的<u>密码学原语</u>（即抗碰撞哈希函数，结合<u>随机预言机模型</u>以消除交互），本章的方法则基于“公钥”<u>密码学原语</u>。“公钥”<u>密码学原语</u>依赖于更强的密码学假设，例如<u>椭圆曲线群</u>中<u>离散对数问题</u>的难解性。在第16.3节中，我们将讨论两种承诺的各自优缺点，即基于IOP的多项式承诺，以及本章将描述的承诺方案。

*本章所描述方案的概述。* 目前已知的多项式承诺方案，比想象中的往往更具一般性。这些方案中，证明者被要求对任意向量 $u \in F_n$ 进行承诺，并在随后响应验证者提出的向量请求 $y \in F_n$，提供关于 $y$ 与 $u$ 的内积的某个命题的证明。在多项式承诺方案中，多项式 $q$ 会以某种基的方式来表示，而 $u$ 是相应的 $q$ 的系数（例如，单变量多项式可以用<u>标准单项式</u>为基进行表示，而<u>多线性多项式</u>则可以用<u>拉格朗日基</u>来表示）。赋值 $q(z)$ 就相当于计算 $y$ 和 $u$ 的内积，这里的 $y$ 是所有<u>基多项式</u>在 $z$ 处进行赋值而得到的向量。

举个例子，如果 $q$ 是单变量多项式， $q$ 可以表示为  $q(X)=\displaystyle\sum_{i=0}^{n-1} u_i X^i$  。而对于任意 $z$， $q$ 在 $z$ 处的赋值为 $q(z) = \langle u,y \rangle = \displaystyle\sum_{i=0}^{n-1} u_i y_i$，也就是 $u$ 和  $y$ 的内积。其中 $y$ 由 $z$ 的各次幂组成，表示为 $y = (1, z, z^2, ..., z^{n-1}) $。类似地，如果 $q$ 是多线性的， $q$ 可以表示为 $q(X) = \displaystyle\sum_{i=0}^{2^\ell} u_i \chi_i(X)$，其中 $\chi_1,...,\chi_{2^\ell}$  表示<u>拉格朗日基多项式</u>的自然枚举（注： 165）。那么对于任意 $z \in F_p^\ell$ , $q(z) = \langle u,y \rangle$ 。这里 $y = \langle \chi_1(z),...,\chi_{2^\ell}(z) \rangle$ 是这些基多项式在 $z$ 处的赋值。

注165：参考引理3.7中，对<u>拉格朗日基多项式</u>的定义。而<u>拉格朗日基多项式</u>的自然枚举可以这样表示：假设 $i$ 的二进制表示为 $i_1, ..., i_\ell \in {\lbrace 0,1\rbrace}^\ell$ ， $\chi_i(X_1,...,X_\ell)$ 
$=\displaystyle\prod_{j=1}^{\ell} \big(X_j i_j + (1 - X_j)(1- i_j)\big)$ 
$=\bigg(\displaystyle\prod_{j: i_j=1} X_j\bigg) \bigg(\displaystyle\prod_{j:i_j=0} (1-X_j) \bigg)$ 。

因此，要给出 $q$ 的承诺，只需给出 $q$ 的系数向量 $u$ 的承诺。而且，要披露 $q(z)$ 或者披露 $q(z)$ 的承诺，只需披露 $u$ 与向量 $y$ 的内积或者其承诺即可。

**赋值向量中的张量结构。** 和10.5.1节中一样，在上述的无论单变量还是多线性多项式情形中，向量 $y$ 都具有<u>张量积</u>的结构。在本章将讨论的一部分多项式承诺方案中，这种张量结构将会被利用上（尤其是14.3节和15.4节中的方案）。其它方案则支持用任意向量 $y$ 和承诺向量进行内积。

这里的所谓张量结构可以这样来描述。在单变量多项式情形中，设 $n-1$ 为多项式 $q$ 的次数，并假设 $n=m^2$ 是一个完全平方数，定义 $a,b \in F_m$ 为 $a := (1,z,z^2,...,z^{m-1})$ 以及 $b := (1,z^m,z^{2m},...,z^{m(m-1)})$ 。如果我们将 $y$ 视为一个的 $m \times m$ 阶矩阵，并且其元素可以用 $(y_{1,1},...,y_{m,m})$ 来进行索引的话， $y$ 就是 $a$ 和 $b$ 的外积 $b\cdot a^T$ 。也就是， $y_{i,j} = z^{i\cdot m+j} = b_i \cdot a_j$ 。同样，如果 $q$ 是 $\ell$ 元多线性多项式，假设 $2^\ell = m^2$ ，用 $z_1,z_2 \in F^{\ell/2}$ 分别表示 $z \in F^\ell$ 的前半部分和后半部分，然后让 $\chi'_1,...,\chi'_m$ 表示 $(\ell/2)$ 元拉格朗日基多项式的自然枚举，并定义 $a,b \in F_m$ 为 
$a := \big(\chi'_1(z_1),...,\chi'_m(z_1)\big)$ ， 
$`b := \big(\chi'_1(z_2),...,\chi'_m(z_2)\big)`$ ， 
那么 $y = b \cdot a^T$ 。也就是说，$y_{i,j} = \chi_{i \cdot m + j}(z)$   $= \chi'_i(z_1) \cdot \chi'_j(z_2)$   $= b_i \cdot a_j$ 。

总结一下，对于单变量和多线性多项式 $q$ ，一旦承诺了 $q$ 的系数向量 $u$ ，计算 $q(z)$ 等同于计算 $u$ 与满足 $y_{i,j} = b_i \cdot a_j$ 的向量 $y$ 的内积，其中 $a,b$ 是某个 $m$ 维向量，而 $m$ 是 $q$ 的系数个数的平方根。等价的，我们可以将 $u$ 和 $y$ 的内积表示为<u>向量-矩阵-向量</u>的乘积： (14.1)

$$ \langle u,y \rangle = \displaystyle\sum_{i,j=1,...,m} u_{i,j} b_ i a_j = b^T \cdot u \cdot a$$

在上述等式的右侧，我们将 $u$ 当作一个 $m \times m$ 阶矩阵。具体的例子，可以参见图 14.1 和 14.2。

## 14.1 线性大小承诺的零知识方案

我们先来描述一个方案，该方案并不比所谓平凡承诺的代价小，但它确实是零知识的。也就是说，证明者对 $q$ 的承诺和 $q$ 本身一样大，而且只要得到这个对 $q$ 的承诺，验证者就可以选择任意的 $z$ ，并自行计算出对赋值 $q(z)$ 的承诺。

回顾一下，在Pedersen承诺（第12.3节）中，我们有一个阶为素数 $p$ 的群 $𝔾$，以及生成元 $g,h$ ，对值 $m \in F_p$ ，其承诺为 $c \gets h^m \cdot g^r$ ，其中 $r \in \lbrace 0,...,p-1 \rbrace$ 是一个由承诺者选择的随机值。Pedersen承诺是完全隐藏和计算约束的 (perfectly hiding and computationally binding)。

*承诺阶段。* 为了对多项式 $q$ 进行承诺，在平凡承诺方案中，证明者直接把多项式的系数向量 $u$ 发送给验证者，但在本方案中，验证者转而发送 $u$ 的每个元素 $u_i$ 的Pedersen承诺 $c_i$。Pedersen承诺是隐藏的（hiding），所以接收承诺 $c_i$ 的人将对 $u$ 一无所知。

*赋值阶段。* 设 $y$ 为一个向量，而 $q(z) = \langle u,y \rangle = \displaystyle\sum_i u_i y_i$。由于验证者知道 $y$ ，并且知道 $u$ 的每个元素 $u_i$ 的承诺 $c_i$ ，利用Pedersen承诺的同态性质，验证者可以自行计算出对 $\displaystyle\sum_i u_i y_i$ 的承诺 $c$ 。 $\mathcal{P}$ 可以通过协议7（第12.3.1节），零知识的证明它知道如何打开承诺 $c$ 。







