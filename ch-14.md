# 第十四章 基于离散对数困难性的多项式承诺

*多项式承诺以及一个简单方案。* 回想一下，所谓的多项式承诺，实际上是针对如下理想化过程的一个模拟。有一个不受信任的证明者 $\mathcal{P}$，他脑子里有一个多项式 $q$（在所谓<u>简洁论证</u>的相关应用里面，对于多项式 $q$，我们主要关心两种情况，一是单变量多项式，一是多线性多项式）。$\mathcal{P}$ 向验证者 $\mathcal{V}$ 发送 $q$ 的完整描述（比如，$q$的所有系数组成的列表）。$\mathcal{V}$ 得到 $q$ 后，可以选择任何点 $z$，并在 $z$ 点对多项式 $q$ 进行赋值。而一旦 $\mathcal{P}$ 将多项式 $q$ 发送给 $\mathcal{V}$，无论 $\mathcal{V}$ 选择在哪个点对多项式进行赋值， $\mathcal{P}$ 都无法再更换多项式 $q$ 本身（译者：“无法更换”在这里过于明显，让人觉得多此一举，其贴切含义需要阅读后续内容）。在上述过程中，$\mathcal{P}$ 显式地将多项式 $q$ 的完整描述发送给 $\mathcal{V}$，我们称其为一个平凡的多项式承诺方案。

上述平凡的多项式承诺方案存在三个潜在问题，其中有两个和效率有关。

* 如果将多项式承诺应用于 SNARK（见第7-10章），多项式 $q$ 可能非常大。 事实上，$q$ 通常与所要证明的整个命题一样大。因此，让 $\mathcal{P}$ 将 $q$ 的所有系数都发送给 $\mathcal{V}$ 的话，将产生大量的通信。所以，使用上述平凡的多项式承诺将无法产生<u>简洁论证</u>。

* $\mathcal{V}$ 为了计算 $q(z)$ ，需要花费的时间将与多项式的系数个数成正比。如果我们希望产生更加节省计算量的论证， 也就是说，希望验证者能够更快的接收并验证证据的话， 上述平凡的承诺方案将无法满足要求。

* $\mathcal{V}$ 获得了整个多项式 $q$。这可能与零知识的要求冲突。在 SNARK 的应用中，$q$ 通常是某个证据的编码，而将整个$q$ 发送给 $\mathcal{V}$ 的话， 就泄漏了这个证据的全部。

使用密码学工具，我们可以在克服上述三个问题的同时，实现与平凡多项式承诺方案相同的功能。具体而言，针对多项式 $q$ ，$\mathcal{P}$ 可以计算一个压缩过的承诺 $c$，并把 $c$ 发送给验证者。压缩意味着 $c$ 比 $q$ 小得多，这就解决了上述关于简洁性的第一个问题。同时，由于 $c$ 比 $q$ （译者：原文为$p$，疑似有误） 本身小，所以 $c$ 并未将 $\mathcal{P}$ 拥有的 $q$ 完全固定下来。这也就是说，对许多不同的多项式而言，$c$ 都是有效的承诺，对随后的进一步的验证请求，$\mathcal{P}$ 还有更多的选择空间。当验证者要求 $\mathcal{P}$ 计算 $q(z)$ 时，$\mathcal{P}$ 还能够在多个符合承诺为 $c$ 的多项式中，选择一个 $p$ ，并返回对应的赋值 $p(z)$。虽然如此，我们依然可能设计出一种多项式承诺方案，并要求其在可计算意义上对 $q$ 进行了固定。这里的意思是，任何<u>有效证明者</u>（比如，无法解决离散对数问题或在密码哈希函数中无法有效找到碰撞的证明者），在处理针对所承诺的多项式的赋值请求 $z$ 时，都无法用 $q(z)$ 以外的任何值来进行回应。更准确地说，除了声称 $q(z)$ 值为 $v$ 之外，证明者还将发送一个赋值证明 $\pi$。<u>可计算约束</u>保证了，除非有 $v=q(z)$，否则任何<u>有效证明者</u>都无法生成一个令人信服的 $\pi$。



