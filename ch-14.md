# 第十四章 基于离散对数困难性的多项式承诺

*多项式承诺以及一个简单方案。* 回想一下，所谓的多项式承诺，实际上是针对如下理想化过程的一个模拟。有一个不受信任的证明者 $\mathcal{P}$，他脑子里有一个多项式 $q$（在所谓<u>简洁论证</u>的相关应用里面，对于多项式 $q$，我们主要关心两种情况，一是单变量多项式，一是多线性多项式）。 $\mathcal{P}$ 向验证者 $\mathcal{V}$ 发送 $q$ 的完整描述（比如， $q$ 的所有系数组成的列表）。 $\mathcal{V}$ 得到 $q$ 后，可以选择任何点 $z$，并在 $z$ 点对多项式 $q$ 进行赋值。而一旦 $\mathcal{P}$ 将多项式 $q$ 发送给 $\mathcal{V}$，无论 $\mathcal{V}$ 选择在哪个点对多项式进行赋值， $\mathcal{P}$ 都无法再更换多项式 $q$ 本身（译者：“无法更换”在这里过于明显，让人觉得多此一举，其贴切含义需要阅读后续内容）。在上述过程中， $\mathcal{P}$ 显式地将多项式 $q$ 的完整描述发送给 $\mathcal{V}$，我们称其为一个平凡的多项式承诺方案。

上述平凡的多项式承诺方案存在三个潜在问题，其中有两个和效率有关。

* 如果将多项式承诺应用于 SNARK（见第7-10章），多项式 $q$ 可能非常大。 事实上， $q$ 通常与所要证明的整个命题一样大。因此，让 $\mathcal{P}$ 将 $q$ 的所有系数都发送给 $\mathcal{V}$ 的话，将产生大量的通信。所以，使用上述平凡的多项式承诺将无法产生<u>简洁论证</u>。

* $\mathcal{V}$ 为了计算 $q(z)$ ，需要花费的时间将与多项式的系数个数成正比。如果我们希望产生更加节省计算量的论证， 也就是说，希望验证者能够更快的接收并验证证据的话， 上述平凡的承诺方案将无法满足要求。

* $\mathcal{V}$ 获得了整个多项式 $q$。这可能与零知识的要求冲突。在 SNARK 的应用中， $q$ 通常是某个证据的编码，而将整个 $q$ 发送给 $\mathcal{V}$ 的话， 就泄漏了这个证据的全部。

使用密码学工具，我们可以在克服上述三个问题的同时，实现与平凡多项式承诺方案相同的功能。具体而言，针对多项式 $q$ ， $\mathcal{P}$ 可以计算一个压缩的承诺 $c$，并把 $c$ 发送给验证者。压缩意味着 $c$ 比 $q$ 小得多，这就解决了关于简洁性的第一个问题。同时，由于 $c$ 比 $q$ （译者：原文为 $p$ ，疑似有误） 本身小，所以 $c$ 并未将 $\mathcal{P}$ 拥有的 $q$ 完全固定下来。这也就是说，对许多不同的多项式而言， $c$ 都是有效的承诺，对随后的进一步的验证请求， $\mathcal{P}$ 还有一定的选择空间。当验证者要求 $\mathcal{P}$ 计算 $q(z)$ 时， $\mathcal{P}$ 还能够在多个符合承诺为 $c$ 的多项式中，选择一个 $p$ ，并返回对应的赋值 $p(z)$。虽然如此，我们依然可能设计出一种多项式承诺方案，并要求其在可计算意义上对 $q$ 进行了固定。这里的意思是，任何<u>有效证明者</u>（比如，无法解决离散对数问题，或在密码哈希函数中无法找到碰撞的证明者），在处理针对所承诺的多项式的赋值请求 $z$ 时，都无法用 $q(z)$ 以外的任何值来进行回应。更准确地说，除了声称 $q(z)$ 的值为 $v$ 之外，证明者还将发送一个赋值证明 $\pi$。<u>可计算约束</u>保证了，除非有 $v=q(z)$，否则任何<u>有效证明者</u>都无法生成一个令人信服的 $\pi$。

在前面的章节中，我们介绍过一些多项式承诺方案（例如，第10.4.2节和第10.5节）。在本章，我们将讨论更多的承诺方案。这些方案和之前的那些方案类似，在 $\pi$ 的验证上，所花费的时间，相比于即使仅仅读取完整 $q$ 所需的时间，都要少得多。这就解决了平凡承诺方案的前两个问题（即简洁性和验证需要花费太多时间的问题）。我们还将看到一些方案，在这些方案中，证据 $\pi$ 不会泄露关于 $q$ 的任何信息。甚至还有一些方案，其中验证者实际上连 $q(z)$ 都不知道，而作为替代，只会得到一个 $q(z)$ 的隐藏承诺。有了这些方案，多项式承诺就可以支持<u>零知识</u>，而不会泄露关于 $q$（当然也包括它所编码的证据）的任何信息给验证者。

*揭示 $q(z)$ 本身还是对 $q(z)$ 的承诺。* 本章描述的多项式承诺方案，将向验证者揭示赋值 $v = q(z)$ 的<u>（Pedersen）承诺</u>（译者：而不是 $v$ 本身）。这是因为第13.2节中的<u>零知识论证</u>需要如此。而其它<u>零知识论证</u>（如第13.3节）则要求 $v$ 被显式的揭示出来。幸运的是，如果想要修改本章的承诺方案，以向验证者揭示 $v$ ，也是比较容易做到的。例如，可以让证明者使用协议3，在保证零知识的同时，向验证者<u>打开</u>对 $v$ 的承诺，也就是揭示 $v$ 的值（参见第12.3.1节的最后一段）。而后面将在第15章描述，在基于<u>配对</u>的多项式承诺方案中，赋值 $v = q(z)$ 将被显式的揭示给验证者。

*前面章节的多项式承诺对比本章将要描述的方案。* 之前讲到，一种构建多项式承诺的方法是，将某种合适的PCP或IOP与<u>Merkle哈希</u>结合起来（第10.4.2节和第10.5节）。相比于<u>Merkle哈希</u>方法利用的是“对称密钥”的<u>密码学原语</u>（即抗碰撞哈希函数，结合<u>随机预言机模型</u>以消除交互），本章的方法则基于“公钥”<u>密码学原语</u>。“公钥”<u>密码学原语</u>依赖于更强的密码学假设，例如<u>椭圆曲线群</u>中<u>离散对数问题</u>的难解性。在第16.3节中，我们将讨论两种承诺的各自优缺点，即基于IOP的多项式承诺，以及本章将描述的承诺方案。

*本章所描述方案的概述。* 目前已知的多项式承诺方案，比想象中的往往更加通用。这些方案中，证明者被要求对任意向量 $u \in F_n$ 进行承诺，并在随后响应验证者提出的向量请求 $y \in F_n$，提供关于 $y$ 与 $u$ 的内积的某个命题的证明。在多项式承诺方案中，多项式 $q$ 会以某种基的方式来表示，而 $u$ 是相应的 $q$ 的系数（例如，单变量多项式可以用<u>标准单项式</u>为基进行表示，而<u>多线性多项式</u>则可以用<u>拉格朗日基</u>来表示）。赋值 $q(z)$ 就相当于计算 $y$ 和 $u$ 的内积，这里的 $y$ 是所有<u>基多项式</u>在 $z$ 处进行赋值而得到的向量。

举个例子，如果 $q$ 是单变量多项式， $q$ 可以表示为 $q(X) = \sum^{n-1}_{i=0} u_i X^i$ 。而对于任意 $z$， $q$ 在 $z$ 处的赋值为 $q(z) = \langle u,y \rangle = \sum_{i=0}^{n-1} u_i y_i$，也就是 $u$ 和  $y$ 的内积。其中 $y$ 由 $z$ 的各次幂组成，表示为 $y = (1, z, z^2, ..., z^{n-1}) $。类似地，如果 $q$ 是多线性的，$q$ 可以表示为 $q(X) = \sum_{i=0}^{2^\ell} u_i \chi_i(X)$，其中 $\chi_1,...,\chi_{2^\ell}$  表示<u>拉格朗日基多项式</u>的自然枚举（注： 165）。那么对于任意 $z \in F_p^\ell$ , $q(z) = \langle u,y \rangle$ 。这里 $y = \langle \chi_1(z),...,\chi_{2^\ell}(z) \rangle$ 是这些基多项式在 $z$ 处的赋值。

注165：参考引理3.7中，对<u>拉格朗日基多项式</u>的定义。而<u>拉格朗日基多项式</u>的自然枚举可以这样表示：假设 $i$ 的二进制表示为 $i_1, ..., i_\ell \in \{0,1\}^\ell$，$\chi_i(X_1,...,X_\ell) = \prod _{j=1}^\ell (X_j i_j + (1 - X_j)(1- i_j)) = (\prod _{j: i_j=1} X_j) (\prod _{j:i_j=0} (1-X_j)) $。

因此，要给出 $q$ 的承诺，只需给出 $q$ 的系数向量 $u$ 的承诺。而且，要揭示 $q(z)$ 或者揭示 $q(z)$ 的承诺，只需揭示 $u$ 与向量 $y$ 的内积或者其承诺即可。


